name: jira-sync-from-gh-issue

on:
  workflow_call:
    inputs:
      jira_project_key:
        type: string
        required: true

      issue_type_map_json:
        type: string
        required: false
        default: |
          {
            "âœ¨ feat": "ìŠ¤í† ë¦¬",
            "ğŸ› fix": "ë²„ê·¸",
            "ğŸš‘ hotfix": "ë²„ê·¸",

            "ğŸ§ª spike": "ì‘ì—…",
            "âœ… test": "ì‘ì—…",
            "â™»ï¸ refactor": "ì‘ì—…",
            "ğŸ¨ style": "ì‘ì—…",
            "ğŸ“• docs": "ì‘ì—…",
            "ğŸ§¹ chore": "ì‘ì—…",
            "ğŸ”§ config": "ì‘ì—…",
            "ğŸ“¦ deps": "ì‘ì—…",
            "ğŸ—ï¸ build": "ì‘ì—…",
            "ğŸš€ deploy": "ì‘ì—…",
            "ğŸ·ï¸ release": "ì‘ì—…",
            "ğŸ›¡ï¸ security": "ì‘ì—…",
            "âš¡ perf": "ì‘ì—…",
            "ğŸ”„ rename": "ì‘ì—…",
            "ğŸ—‘ï¸ remove": "ì‘ì—…",
            "ğŸ”– init": "ì‘ì—…"
          }

      priority_map_json:
        type: string
        required: false
        default: |
          {
            "ğŸ”¥ priority: P0": "Highest",
            "âš ï¸ priority: P1": "High",
            "ğŸ“ priority: P2": "Medium",
            "ğŸ§Š priority: P3": "Low"
          }

      component_map_json:
        type: string
        required: false
        default: |
          {
            "ğŸ—‚ï¸ area: BE": "BE",
            "ğŸ–¥ï¸ area: FE": "FE",
            "ğŸ—„ï¸ area: DB": "DB",
            "â˜ï¸ area: INFRA": "INFRA",
            "ğŸ” area: AUTH": "AUTH"
          }

      github_linked_label:
        type: string
        required: false
        default: "ğŸ”— jira-linked"

      close_on_missing_required_labels:
        type: boolean
        required: false
        default: true

    secrets:
      JIRA_BASE_URL:
        required: true
      JIRA_EMAIL:
        required: true
      JIRA_API_TOKEN:
        required: true

jobs:
  sync:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      contents: write

    steps:
      - name: Guard - skip if already has Jira key in title or jira-linked label
        id: guard
        uses: actions/github-script@v7
        env:
          LINKED_LABEL: ${{ inputs.github_linked_label }}
        with:
          script: |
            const issue = context.payload.issue;
            const title = issue.title || "";
            const labels = (issue.labels || []).map(l => (typeof l === "string" ? l : l.name));
            const hasKey = /\[[A-Z][A-Z0-9_]+-\d+\]/.test(title);
            const hasLinkedLabel = labels.includes(process.env.LINKED_LABEL);
            core.setOutput("skip", (hasKey || hasLinkedLabel) ? "true" : "false");

      - name: Extract type/area/priority labels
        id: pick
        if: steps.guard.outputs.skip != 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const labels = (context.payload.issue.labels || [])
              .map(l => typeof l === "string" ? l : l.name);

            const TYPE = [
              "âœ¨ feat","ğŸ› fix","â™»ï¸ refactor","ğŸ¨ style","âœ… test","ğŸ“• docs","ğŸ§¹ chore","ğŸ”§ config","ğŸ“¦ deps",
              "ğŸ—ï¸ build","ğŸš€ deploy","ğŸ·ï¸ release","ğŸš‘ hotfix","ğŸ›¡ï¸ security","âš¡ perf","ğŸ§ª spike",
              "ğŸ”„ rename","ğŸ—‘ï¸ remove","ğŸ”– init"
            ];
            const AREA = ["ğŸ—‚ï¸ area: BE","ğŸ–¥ï¸ area: FE","ğŸ—„ï¸ area: DB","â˜ï¸ area: INFRA","ğŸ” area: AUTH"];
            const PRIORITY = ["ğŸ”¥ priority: P0","âš ï¸ priority: P1","ğŸ“ priority: P2","ğŸ§Š priority: P3"];

            const type = labels.find(l => TYPE.includes(l)) || "";
            const area = labels.find(l => AREA.includes(l)) || "";
            const priority = labels.find(l => PRIORITY.includes(l)) || "";

            core.setOutput("type", type);
            core.setOutput("area", area);
            core.setOutput("priority", priority);

            const missing = [];
            if (!type) missing.push("type");
            if (!area) missing.push("area");
            if (!priority) missing.push("priority");
            core.setOutput("missing", missing.join(","));

      - name: Enforce required labels
        if: steps.guard.outputs.skip != 'true' && steps.pick.outputs.missing != ''
        uses: actions/github-script@v7
        env:
          MISSING: ${{ steps.pick.outputs.missing }}
          CLOSE_FLAG: ${{ inputs.close_on_missing_required_labels }}
        with:
          script: |
            const { MISSING, CLOSE_FLAG } = process.env;
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.issue.number,
              body: `í•„ìˆ˜ ë¼ë²¨ì´ ëˆ„ë½ë˜ì—ˆìŠµë‹ˆë‹¤: ${MISSING}\n\n- type, area, priority ë¼ë²¨ì„ ëª¨ë‘ ì¶”ê°€í•´ì£¼ì„¸ìš”.`
            });
            if (CLOSE_FLAG === 'true') {
              await github.rest.issues.update({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.issue.number,
                state: "closed"
              });
            }

      - name: Resolve Jira Meta (FAIL if type_id == null)
        id: jira_meta
        if: steps.guard.outputs.skip != 'true' && steps.pick.outputs.missing == ''
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE: ${{ secrets.JIRA_BASE_URL }}
          PROJ: ${{ inputs.jira_project_key }}

          TYPE_LABEL: ${{ steps.pick.outputs.type }}
          AREA_LABEL: ${{ steps.pick.outputs.area }}
          PRIORITY_LABEL: ${{ steps.pick.outputs.priority }}

          TYPE_MAP: ${{ inputs.issue_type_map_json }}
          PRIO_MAP: ${{ inputs.priority_map_json }}
          COMP_MAP: ${{ inputs.component_map_json }}
        run: |
          set -euo pipefail

          curl -sS -u "$JIRA_EMAIL:$JIRA_TOKEN" \
            "$JIRA_BASE/rest/api/3/project/$PROJ" > proj.json

          TYPE_NAME=$(echo "$TYPE_MAP" | jq -r --arg k "$TYPE_LABEL" '.[$k] // "ì‘ì—…"')
          TYPE_ID=$(jq -r --arg n "$TYPE_NAME" '.issueTypes[] | select(.name==$n) | .id' proj.json | head -n 1)

          echo "TYPE_LABEL=$TYPE_LABEL"
          echo "TYPE_NAME=$TYPE_NAME"

          if [ -z "${TYPE_ID:-}" ] || [ "$TYPE_ID" = "null" ]; then
            echo "âŒ Jira IssueType ID not found"
            echo "- picked type label: $TYPE_LABEL"
            echo "- mapped issue type name: $TYPE_NAME"
            echo "- available issue types:"
            jq -r '.issueTypes[].name' proj.json
            exit 1
          fi

          curl -sS -u "$JIRA_EMAIL:$JIRA_TOKEN" \
            "$JIRA_BASE/rest/api/3/priority" > priorities.json

          PRIO_NAME=$(echo "$PRIO_MAP" | jq -r --arg k "$PRIORITY_LABEL" '.[$k] // empty')
          PRIO_ID=$(jq -r --arg n "$PRIO_NAME" '.[] | select(.name==$n) | .id' priorities.json | head -n 1)

          if [ -z "${PRIO_ID:-}" ] || [ "$PRIO_ID" = "null" ]; then
            echo "âŒ Jira Priority ID not found"
            echo "- picked priority label: $PRIORITY_LABEL"
            echo "- mapped priority name: $PRIO_NAME"
            echo "- available priorities:"
            jq -r '.[].name' priorities.json
            exit 1
          fi

          COMP_NAME=$(echo "$COMP_MAP" | jq -r --arg k "$AREA_LABEL" '.[$k] // empty')
          curl -sS -u "$JIRA_EMAIL:$JIRA_TOKEN" \
            "$JIRA_BASE/rest/api/3/project/$PROJ/components" > components.json

          COMP_ID=$(jq -r --arg n "$COMP_NAME" '.[] | select(.name==$n) | .id' components.json | head -n 1)
          if [ -z "${COMP_ID:-}" ] || [ "$COMP_ID" = "null" ]; then
            COMP_ID="null"
          fi

          echo "type_id=$TYPE_ID" >> "$GITHUB_OUTPUT"
          echo "priority_id=$PRIO_ID" >> "$GITHUB_OUTPUT"
          echo "component_id=$COMP_ID" >> "$GITHUB_OUTPUT"

      - name: Create Jira issue
        id: create
        if: steps.guard.outputs.skip != 'true' && steps.pick.outputs.missing == ''
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE: ${{ secrets.JIRA_BASE_URL }}
          PROJ: ${{ inputs.jira_project_key }}

          GH_TITLE: ${{ github.event.issue.title }}
          GH_BODY: ${{ github.event.issue.body }}
          GH_URL: ${{ github.event.issue.html_url }}

          TYPE_ID: ${{ steps.jira_meta.outputs.type_id }}
          PRIO_ID: ${{ steps.jira_meta.outputs.priority_id }}
          COMP_ID: ${{ steps.jira_meta.outputs.component_id }}
        run: |
          set -euo pipefail

          DESC="GitHub Issue: $GH_URL\n\n$GH_BODY"

          jq -n \
            --arg proj "$PROJ" \
            --arg tid "$TYPE_ID" \
            --arg pid "$PRIO_ID" \
            --arg sum "$GH_TITLE" \
            --arg desc "$DESC" \
            '{
              fields: {
                project: { key: $proj },
                issuetype: { id: $tid },
                priority: { id: $pid },
                summary: $sum,
                description: {
                  type: "doc",
                  version: 1,
                  content: [{
                    type: "paragraph",
                    content: [{ type: "text", text: $desc }]
                  }]
                }
              }
            }' > payload.json

          if [ "$COMP_ID" != "null" ] && [ -n "$COMP_ID" ]; then
            jq '.fields.components = [{id: $id}]' --arg id "$COMP_ID" payload.json > tmp.json && mv tmp.json payload.json
          fi

          http=$(curl -sS -u "$JIRA_EMAIL:$JIRA_TOKEN" \
            -o res.json -w "%{http_code}" \
            -X POST -H "Content-Type: application/json" \
            -d @payload.json "$JIRA_BASE/rest/api/3/issue")

          if [ "$http" -lt 200 ] || [ "$http" -ge 300 ]; then
            echo "âŒ Jira create failed. HTTP=$http"
            cat res.json | jq .
            exit 1
          fi

          JIRA_KEY=$(jq -r '.key' res.json)
          if [ -z "$JIRA_KEY" ] || [ "$JIRA_KEY" = "null" ]; then
            echo "âŒ Jira create returned no key"
            cat res.json | jq .
            exit 1
          fi

          echo "jira_key=$JIRA_KEY" >> "$GITHUB_OUTPUT"

      - name: Update GitHub Issue (force "<type>: " prefix)
        if: steps.guard.outputs.skip != 'true' && steps.create.outputs.jira_key != ''
        uses: actions/github-script@v7
        env:
          JIRA_KEY: ${{ steps.create.outputs.jira_key }}
          JIRA_BASE: ${{ secrets.JIRA_BASE_URL }}
          LABEL: ${{ inputs.github_linked_label }}
          TYPE_LABEL: ${{ steps.pick.outputs.type }}
        with:
          script: |
            const { JIRA_KEY, JIRA_BASE, LABEL, TYPE_LABEL } = process.env;
            const issue = context.payload.issue;

            const typeToPrefix = {
              "âœ¨ feat": "feat",
              "ğŸ› fix": "fix",
              "â™»ï¸ refactor": "refactor",
              "ğŸ¨ style": "style",
              "âœ… test": "test",
              "ğŸ“• docs": "docs",
              "ğŸ§¹ chore": "chore",
              "ğŸ”§ config": "config",
              "ğŸ“¦ deps": "deps",
              "ğŸ—ï¸ build": "build",
              "ğŸš€ deploy": "deploy",
              "ğŸ·ï¸ release": "release",
              "ğŸš‘ hotfix": "hotfix",
              "ğŸ›¡ï¸ security": "security",
              "âš¡ perf": "perf",
              "ğŸ§ª spike": "spike",
              "ğŸ”„ rename": "rename",
              "ğŸ—‘ï¸ remove": "remove",
              "ğŸ”– init": "init"
            };

            const prefix = typeToPrefix[TYPE_LABEL];
            if (!prefix) {
              throw new Error(`type label not found or unmapped: ${TYPE_LABEL}`);
            }

            const rawTitle = issue.title || "";
            const withoutJira = rawTitle.replace(/^\[[A-Z][A-Z0-9_]+-\d+\]\s+/, "");
            const baseTitle = withoutJira.replace(/^[a-zA-Z0-9_-]+:\s+/i, "").trim();

            const newTitle = `[${JIRA_KEY}] ${prefix}: ${baseTitle}`;

            await github.rest.issues.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              title: newTitle
            });

            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              body: `âœ… Jira í‹°ì¼“ ìƒì„±ë¨: [${JIRA_KEY}](${JIRA_BASE}/browse/${JIRA_KEY})`
            });

            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue.number,
              labels: [LABEL]
            });

      - name: Create branch <type>/<JIRA_KEY>
        if: steps.guard.outputs.skip != 'true' && steps.create.outputs.jira_key != ''
        uses: actions/github-script@v7
        env:
          JIRA_KEY: ${{ steps.create.outputs.jira_key }}
          TYPE_LABEL: ${{ steps.pick.outputs.type }}
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const jiraKey = process.env.JIRA_KEY;
            const typeLabel = process.env.TYPE_LABEL;

            const typeToPrefix = {
              "âœ¨ feat": "feat",
              "ğŸ› fix": "fix",
              "â™»ï¸ refactor": "refactor",
              "ğŸ¨ style": "style",
              "âœ… test": "test",
              "ğŸ“• docs": "docs",
              "ğŸ§¹ chore": "chore",
              "ğŸ”§ config": "config",
              "ğŸ“¦ deps": "deps",
              "ğŸ—ï¸ build": "build",
              "ğŸš€ deploy": "deploy",
              "ğŸ·ï¸ release": "release",
              "ğŸš‘ hotfix": "hotfix",
              "ğŸ›¡ï¸ security": "security",
              "âš¡ perf": "perf",
              "ğŸ§ª spike": "spike",
              "ğŸ”„ rename": "rename",
              "ğŸ—‘ï¸ remove": "remove",
              "ğŸ”– init": "init"
            };

            const type = typeToPrefix[typeLabel];
            if (!type) throw new Error(`type label unmapped: ${typeLabel}`);

            const branchName = `${type}/${jiraKey}`;              // âœ… <type>/í‹°ì¼“ë²ˆí˜¸
            const getRefArg = `heads/${branchName}`;              // GETì€ refs/ ì—†ì´
            const createRefArg = `refs/heads/${branchName}`;      // CREATEëŠ” refs/ í¬í•¨

          
            try {
              await github.rest.git.getRef({ owner, repo, ref: getRefArg });
              core.info(`Branch already exists: ${branchName}`);
              return;
            } catch (e) {
              if (e.status !== 404) throw e;
            }

            
            const repoInfo = await github.rest.repos.get({ owner, repo });
            const defaultBranch = repoInfo.data.default_branch;

            const base = await github.rest.repos.getBranch({
              owner, repo, branch: defaultBranch
            });

            const sha = base.data.commit.sha;

            await github.rest.git.createRef({
              owner,
              repo,
              ref: createRefArg,
              sha
            });

            core.info(`Created branch: ${branchName}`);

    
            await github.rest.issues.createComment({
               owner, repo, issue_number: context.payload.issue.number,
               body: `ğŸŒ¿ ë¸Œëœì¹˜ ìƒì„±ë¨: \`${branchName}\` (base: ${defaultBranch})`
             });
