name: jira-sync-on-pr
on:
  workflow_call:
    secrets:
      JIRA_BASE_URL: { required: true }
      JIRA_EMAIL: { required: true }
      JIRA_API_TOKEN: { required: true }

      SLACK_WEBHOOK_BE: { required: false }
      SLACK_WEBHOOK_FE: { required: false }
      SLACK_WEBHOOK_INFRA: { required: false }
      SLACK_WEBHOOK_DEFAULT: {required: false}

      
jobs:
  pr-sync:
    runs-on: ubuntu-latest
    permissions:
      issues: write
      pull-requests: write
      contents: read
    steps:
      # 1. PR Î≥∏Î¨∏ÏóêÏÑú Îç∞Ïù¥ÌÑ∞ Ï∂îÏ∂ú
      - name: Extract Metadata
        id: meta
        uses: actions/github-script@v7
        with:
          script: |
            const body = context.payload.pull_request.body || ""; 
            const jiraKey = body.match(/[A-Z][A-Z0-9]+-[0-9]+/)?.[0];
            const issueNumber = body.match(/closes\s+#(\d+)/i)?.[1];
            core.setOutput('jira_key', jiraKey || '');
            core.setOutput('issue_number', issueNumber || '');
     
      - name: Sync Labels from Issue
        id: sync_labels
        if: github.event.action == 'opened' && steps.meta.outputs.issue_number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const issue_number = parseInt("${{ steps.meta.outputs.issue_number }}");
            
            const issue = await github.rest.issues.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: issue_number
            });
            
            const labels = issue.data.labels.map(l => typeof l === 'string' ? l : l.name);
            
            const typeLabel = labels.find(l => 
              l.startsWith('‚ú®') || l.startsWith('üêõ') || l.startsWith('üöë') || 
              l.startsWith('‚ôªÔ∏è') || l.startsWith('üé®') || l.startsWith('‚úÖ') ||
              l.startsWith('üìï') || l.startsWith('üßπ') || l.startsWith('üîß') ||
              l.startsWith('üì¶') || l.startsWith('üèóÔ∏è') || l.startsWith('üöÄ') ||
              l.startsWith('üè∑Ô∏è') || l.startsWith('üõ°Ô∏è') || l.startsWith('‚ö°') ||
              l.startsWith('üß™') || l.startsWith('üîÑ') || l.startsWith('üóëÔ∏è') ||
              l.startsWith('üîñ')
            );
            
            core.setOutput('type_label', typeLabel || '');
            const areaLabel = labels.find(l => 
              l.includes('BE') || l.includes('FE') || l.includes('INFRA')
            );

            const priorityLabel = labels.find(l =>
              l.startsWith('P0') || l.startsWith('P1') || l.startsWith('P2')
            );

            
            core.setOutput('area_label', areaLabel || '');
            core.setOutput('priority_label', priorityLabel || '');
            
            if (labels.length > 0) {
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                labels: labels
              });
            }

      # 2. PR Ï†úÎ™©Ïóê [Ìã∞ÏºìÎ≤àÌò∏] <type>: ÏûêÎèô Ï∂îÍ∞Ä
      - name: Update PR Title
        if: github.event.action == 'opened' && steps.meta.outputs.jira_key != ''
        uses: actions/github-script@v7
        env:
          JIRA_KEY: ${{ steps.meta.outputs.jira_key }}
          TYPE_LABEL: ${{ steps.sync_labels.outputs.type_label }}
        with:
          script: |
            const { JIRA_KEY, TYPE_LABEL } = process.env;
            const pr = context.payload.pull_request;
            
            const typeMap = {
              "‚ú® feat": "feat",
              "üêõ fix": "fix",
              "üöë hotfix": "hotfix",
              "‚ôªÔ∏è refactor": "refactor",
              "üé® style": "style",
              "‚úÖ test": "test",
              "üìï docs": "docs",
              "üßπ chore": "chore",
              "üîß config": "config",
              "üì¶ deps": "deps",
              "üèóÔ∏è build": "build",
              "üöÄ deploy": "deploy",
              "üè∑Ô∏è release": "release",
              "üõ°Ô∏è security": "security",
              "‚ö° perf": "perf",
              "üß™ spike": "spike",
              "üîÑ rename": "rename",
              "üóëÔ∏è remove": "remove",
              "üîñ init": "init"
            };
            
            const commitType = typeMap[TYPE_LABEL] || "task";
            
            let cleanTitle = pr.title
              .replace(/^\[[A-Z0-9-]+\]\s*/, "")
              .replace(/^(feat|fix|hotfix|refactor|style|test|docs|chore|config|deps|build|deploy|release|security|perf|spike|rename|remove|init|task):\s*/i, "")
              .trim();
            
        
            const newTitle = `[${JIRA_KEY}] ${commitType}: ${cleanTitle}`;
            
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              title: newTitle
            });

      # 4. Slack Alarm
      - name: Notify Slack (route by area label)
        if: github.event.action == 'opened'
        env:
          AREA_LABEL: ${{ steps.sync_labels.outputs.area_label }}
          TYPE_LABEL: ${{ steps.sync_labels.outputs.type_label }}
          PRIORITY_LABEL: ${{ steps.sync_labels.outputs.priority_label }}
          JIRA_KEY: ${{ steps.meta.outputs.jira_key }}

          SLACK_WEBHOOK_BE: ${{ secrets.SLACK_WEBHOOK_BE }}
          SLACK_WEBHOOK_FE: ${{ secrets.SLACK_WEBHOOK_FE }}
          SLACK_WEBHOOK_INFRA: ${{ secrets.SLACK_WEBHOOK_INFRA }}
          SLACK_WEBHOOK_DEFAULT: ${{ secrets.SLACK_WEBHOOK_DEFAULT }}
        run: |
          set -euo pipefail

          if [ -z "${SLACK_WEBHOOK_DEFAULT:-}" ] && [ -z "${SLACK_WEBHOOK_BE:-}" ] && [ -z "${SLACK_WEBHOOK_FE:-}" ] && [ -z "${SLACK_WEBHOOK_INFRA:-}" ]; then
            echo "No Slack webhook configured. Skip."
            exit 0
          fi

          WEBHOOK="${SLACK_WEBHOOK_DEFAULT:-}"

          if [[ "${AREA_LABEL:-}" == *"INFRA"* ]] && [ -n "${SLACK_WEBHOOK_INFRA:-}" ]; then
            WEBHOOK="$SLACK_WEBHOOK_INFRA"
          elif [[ "${AREA_LABEL:-}" == *"BE"* ]] && [ -n "${SLACK_WEBHOOK_BE:-}" ]; then
            WEBHOOK="$SLACK_WEBHOOK_BE"
          elif [[ "${AREA_LABEL:-}" == *"FE"* ]] && [ -n "${SLACK_WEBHOOK_FE:-}" ]; then
            WEBHOOK="$SLACK_WEBHOOK_FE"
          fi

          if [ -z "${WEBHOOK:-}" ]; then
            echo "No Slack webhook resolved. Skip."
            exit 0
          fi

          PR_URL="${{ github.event.pull_request.html_url }}"
          PR_TITLE="${{ github.event.pull_request.title }}"
          REPO="${{ github.repository }}"
          AUTHOR="${{ github.event.pull_request.user.login }}"

          TEXT="*PR Opened*  (${REPO})\n‚Ä¢ ${PR_TITLE}\n‚Ä¢ ${PR_URL}\n‚Ä¢ author: ${AUTHOR}\n‚Ä¢ type: ${TYPE_LABEL:-}\n‚Ä¢ area: ${AREA_LABEL:-}\n‚Ä¢ priority: ${PRIORITY_LABEL:-}\n‚Ä¢ jira: ${JIRA_KEY:-}"

          payload=$(jq -n --arg text "$TEXT" '{text:$text}')
          curl -sS -X POST -H 'Content-type: application/json' --data "$payload" "$WEBHOOK"
          
      - name: Transition Jira to Done
        if: github.event.pull_request.merged == true && steps.meta.outputs.jira_key != ''
        env:
          JIRA_EMAIL: ${{ secrets.JIRA_EMAIL }}
          JIRA_TOKEN: ${{ secrets.JIRA_API_TOKEN }}
          JIRA_BASE: ${{ secrets.JIRA_BASE_URL }}
          JIRA_KEY: ${{ steps.meta.outputs.jira_key }}
        run: |
          curl -s -u "$JIRA_EMAIL:$JIRA_TOKEN" -X POST -H "Content-Type: application/json" \
            -d '{"transition": {"id": "31"}}' \
            "$JIRA_BASE/rest/api/3/issue/$JIRA_KEY/transitions"
